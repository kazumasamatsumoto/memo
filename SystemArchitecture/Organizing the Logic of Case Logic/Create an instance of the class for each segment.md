## 区分ごとのクラスのインスタンスを生成する

多態は、利用する側のコードをシンプルにします。

しかし、区分ごとのクラスのインスタンスを生成するときは、if文で場合分けが必要になりそうです。

しかし、ちょっとした工夫でこのif文は不要になります。

例えばMapを使うやり方です。

* if文を使わずに区分ごとのオブジェクトを生成するやり方の例
```
class FeeFactory {
  static Map<String,Fee> types;

  static
  {
    types = new HashMap<String, Fee>();
    types.put( "adult", new AdultFee());
    types.put( "child", new ChildFee());
  }

  static Fee feeByName(String name)
  {
    return types.get(name);
  }
}
```

この例では、料金区分の名前をキーとして、区分ごとのオブジェクトをMapの値として保持しています。

次のように、料金区分名を指定すれば、該当する料金区分のオブジェクトを取得できます。

```
FeeFactory.feeByName("adult")
```

例えば、画面のドロップダウンリストで選択された区分名から対応する区分オブジェクトをfeeByName()メソッドで取得できます。

どの区分が選択されたかをif文で判断する必要はありません。

## Javaの列挙型を使えばもっと簡単

多態は区分ごとのロジックを整理する便利な仕組みです。

しかし、多態には区分の一覧がわかりにくいという問題があります。

同じインターフェースを実装した区分ごとのクラスが同じ方のグループであることは

class宣言を読めば確認できますが、どういう区分体系であるか、

一卵性に欠けます。そのためコードの見通しが悪くなり、変更がやりにくくなります。

Javaでは区分ごとのクラス一覧を明示的に記述できます。それが列挙型(enum)です。列挙型の簡単な使い方を見てみましょう。

* 列挙型の使い方
```
// 料金区分の定義
enum FeeType {
  adult,
  child,
  senior
}

// 区分を使う側のクラス

class Guest {
  FeeType type;

  boolean isAdult() {
    return type.equals(FeeType.adult);
  }
}
```

このように、区分定数の一覧を宣言する列挙型は、Java以外の言語でも用意されています。

　しかし、Javaの列挙型は単純な区分定数ではありません。

Javaでは列挙型もクラスです。

区分ごとの値をインスタンス変数として保持したり、区分ごとのロジックをメソッドとして記述できたりします。

例えば、料金区分を、列挙型と多態を組み合わせて次のように書くことができます。

* 料金区分ごとのロジックをenumを使って表現する
```
enum FeeType {
  adult( new AdultFee() ),
  child( new ChildFee() ),
  senior( new SeniorFee() );

  private Fee fee;
  // Feeインターフェースを実装したどれかのクラスのオブジェクト

  private FeeType(Fee fee) {
    this.fee = fee; 料金区分ごとのオブジェクトを設定する
  }

  Yen yen() {
    return fee.yen();
  }

  String label() {
    return fee.label();
  }
}
```

このように料金区分に関するロジックを整理しておけば、区分名を指定して、区分ごとの料金を計算できます。

* 料金区分名から料金を計算するメソッドの例
```
Yen feeFor(String feeTypeName) {
  FeeType feeType = FeeType.valueOf(feeTypeName); // 例えば、"adult"

  return feeType.yen();
}
```

EnumクラスのvalueOf()メソッドは、if文を使わずにタイプ名から区分ごとのオブジェクトを取得できる便利でわかりやすい方法です。

列挙型を使って、区分ごとのロジックをわかりやすく整理するこの方法を

「区分オブジェクト」と呼びます。

区分定数を単なる定数ではなく、振る舞いを持ったオブジェクトとして表現します。

「振る舞いを持つ」というのは、メソッドを指定して判断/加工/計算を依頼できるという意味です。

この振る舞いを持った区分オブジェクトをうまく使うことで、

区分ごとのif文/switch文でごちゃごちゃしがちなコードをすっきりと見通し良く整理できます。

そして、区分ごとのロジックをそれぞれべちうのクラスに独立させて整理することで、

区分の追加や、区分ごとのロジックの変更が楽で安全になります。

## 区分ごとの業務ロジックを区分オブジェクトで分析し整理する
業務アプリケーションには顧客区分や商品分類など、

様々な区分/分類/種別が登場します。

そして、それらの区分ごとの業務ルールや、

区分を組み合わせた判断ロジックが、業務アプリケーションを複雑にします。

入り組みがちな区分ごとの業務ロジックを、

区分ごとに別のクラスに独立させた区分オブジェクトは、

オブジェクト指向らしいコードの整理のやり方です。

区分ごとのロジックをどこに書くべきかわかりやすくなります。

クラスに分けることで、特定の場合のルールや計算方法を変更しても、

影響範囲をそのクラスに閉じ込めることができます。

インターフェース宣言を使って、区分ごとのクラスを同じ方として扱えば、

使う側のクラスは、区分ごとのクラスの変更の影響を受けにくくなります。

例えば「大人料金」クラスも「子供料金」クラスも料金型として同一視できます。

同じ型として扱うのでコードに区分ごとのif文/switch文は登場しません。

区分の追加や削除があった場合でも、使う側には何も影響しません。

さらに列挙型を使って、業務で扱う区分の一覧を宣言することは、

業務ロジックの見通しをよくし、わかりやすく整理する手段です。

業務要件として区分を発見したら、enumで区分名を列挙してみます。

そして、区分ごとの名称や値を、それぞれの列挙要素のコンストラクタとして指定します。

区分ごとに判断/加工/計算のロジックが違う場合は、

区分ごとのクラスを作成します。

区分オブジェクトの設計と実装は、区分に関わる業務ロジックを把握し、

整理して行く活動そのものです。

業務ロジックの複雑さは、ほとんどの場合、区分や区分の組み合わせに関連します。

その複雑さを分析/整理する手段が区分オブジェクトです。

第１章で説明した「値オブジェクト」や「コレクションオブジェクト」

と同じように、「区分オブジェクト」も業務の関心事と直接的に対応します。

オブジェクト指向では、業務の関心事や業務ロジックを分析し整理する活動と、

クラスを設計する活動は基本的に同じものなのです。
# プログラムを複雑にする「場合分け」のコード

## 区分や種別がコードを複雑にする

ソフトウェアを複雑にし、変更を厄介にする原因の一つが場合わけのロジックです。

業務アプリケーションでは次のような様々な区分や分類を扱います

* 顧客区分
* 料金種別
* 商品分類
* 地域区分
* 製品タイプ

区分や分類は、対象ごとに異なる業務ルールを適用するために使われます。

例えば、特別な顧問だけに割引ルールを適用したり、特定の地域向けの送料を割増にしたりします。

このような区分ごとのロジックを書き分ける基本手段がif文やswitch文です。

しかし、プログラムのあちこちに同じようなif文/switch文が重複すると、区分の追加や区分ごとのルールの変更があった時にプログラムの変更をやりにくくします。

さらに、複数の区分体系を組み合わせて判断する業務ロジックだと、if文の分岐がどんどん複雑になります。

例えば「送料」を計算するために、

「顧客区分」「製品タイプ」「地域区分」の組み合わせで判断する、などです。

入り組んだif文は、見通しが悪く理解が大変になります。

ちょっとした条件分岐の変更が、危険で厄介な作業になります。

このように複雑になりがちな、区分ごとの業務ルールのコードをすっきりと整理して、変更のやりやすいプログラムにするにはどう設計すれば良いでしょうか。

## 判断や処理のロジックをメソッドに独立させる

区分ごとのコードの整理も、第１章で説明したオブジェクト指向の考え方で設計します。

* コードのかたまりは、メソッドとして抽出して独立させる
* 関連するデータとロジックは、1つのクラスにまとめる

まず、コードのかたまりを、メソッドとして抽出して独立させる方法からみていきましょう

* 判断や処理のロジックをそのままif文の中に書く（悪い例）
```
if(customerType.equals("child")) {
  fee = baseFee * 0.5 ;
}
```

このようにif文の中に書かれた判断条件や計算式をそれぞれメソッドに抽出すると、次のようになります。

* メソッドに抽出する（良い例）
```
if(isChild()) {
  fee = childFee()
}

// 判断ロジックの詳細
private Boolean isChild() {
  return customerType.equals("child");
}

// 計算ロジックの詳細
private int childFee() {
  return baseFee * 0.5 ;
}
```

子供を判断する式をisChild()メソッドで定義します。

子供料金の計算をchildFee()メソッドで定義します。

そうすると、元々のif文は、メソッドを呼び出すだけのシンプルな表現になります。

メソッド名を読むだけで何をやろうとしているか明確です。

「子供だったら子供料金にする」

という意図がそのままプログラムのコードで表現できています。

このように判断ロジックと分岐後のロジックを、それぞれメソッドに抽出すると、

コードが整理され、変更が楽で安全になります。

子供の判定ルールを変えるには、isChild()メソッドの実装を変えます。

if文の中にごちゃごちゃと書かれた計算式を変更するよりも、

メソッドに抽出した式を変更する方が簡単で安全です。

変更すべき箇所とその影響範囲を特定のメソッドに閉じ込めることができます。

## else句をなくすと条件分岐が単純になる

場合わけのコードを整理するもう一つのやり方は、

else句を書かないことです。

else句は、プログラムの構造を複雑にします。

else句をできるだけ書かない方が、プログラムが単純になります。

具体例で考えてみましょう。「子供」「大人」「シニア」で別料金にするロジックを、else句を使って書いた例です。

* else句を使った書き方（悪い例）
```
Yen fee() {
  Yen result;
  if(isChild()) {
    result = childFee();
  } else if(isSenior()) {
    result = seniorFee();
  } else {
    result = adultFee();
  }
  return result;
}
```

このコードはローカル変数resultの計算方法をelse句で書き分けています。

しかし、実際にはローカル変数resultは必要ありません。

条件が合致すれば金額が確定します。

ローカル変数を使わずに、条件文の中から直ちに金額を返す書き方ができます

* ローカル変数を使わずに判定後、直ちに結果を返す
```
Yen fee() {

  if(isChild()) {
    return childFee();
  } else if(isSenior()) {
    return seniorFee();
  } else {
    return adultFee();
  }
}
```

ローカル変数がなくなったことで、コードがシンプルでわかりやすくなりました。

コレが早期リターンという書き方です。

早期リターンを使うとelse句を書く必要がありません。

* else句をなくした書き方（良い例）
```
Yen fee() {
  if(isChild()) return childFee();
  if(isSenior()) return seniorFee();
  return adultFee();
}
```

else句がなくなり、すっきりしたコードになりました。

最初のelse句を使ったコードと比較しましょう。

else句を使わずに早期リターンするこの書き方をガード節と呼びます。

マーティン・ファウラーの「リファクタリング」で「条件記述の単純化」として紹介されている設計の改善方法です。

コードの中にelse句を見つけたら、早期リターンやガード節に書き換えることを検討してみましょう。

場合わけのコードをすっきりさせ、変更時にバグが紛れ込む可能性が確実に減ります。

早期リターンやガード節を検討しやすくするために、あらかじめ、条件判断の式や条件文
の中の式をそれぞれメソッドに抽出して起きます。

処理の詳細をメソッドに隠すことで、条件分岐の構造だけに集中して考えることができます。

## 複文は単文に分ける

else句を使った最初の書き方は、if文のelse句の中にif文を書いています。

つまり、ifが入れ子になった複文構造です。

文の中に文を書く「複文」は、日本語の文章であれ、プログラミング言語の記述であれ、

意図をわかりにくくします。

そこで、複文を分解して、単文を並べるシンプルな構造に変えます。

先ほどの例で、else句をなくした書き方がすっきりしているのは、複文を単文の並びに変えたからです。

else句をなくして単文の並びに変えると、区分ごとのロジックの独立性が高くなります。

複文は文と文が密に結合しています。

単文を並べる方式は、文と文の結合度（影響度合い）が下がります。

結合度が小さければ、変更がやりやすくなります。

例えば「幼児」区分を追加してみましょう。

単文を並べた方式であれば、もう一つ単文を追加するだけです。

* 「幼児」区分を追加
```
Yen fee() {

  if(isBaby()) return babyFee();
  if(isChild()) return childFee();
  if(isSenior()) return seniorFee();

  return adultFee();
}
```

また、この3つのif文は順番を入れ替えてもうまく動作します。

if文動詞の関係が「疎結合」だからです。

このように、else句を使わずに独立性の高い単文を並べる書き方は、if-then-else構文で書いた場合分けに比べて、プログラムをわかりやすくし、変更を楽で安全にします。

## 区分ごとのロジックを別クラスに分ける
区分ごとのロジックを独立させるやり方をさらに進めてみましょう。

顧客の区分ごとの料金メソッドとして独立させました。

もっと独立性を高めるために、メソッドではなく区分ごとに別のクラスに分けるやり方があります。

顧客区分ごとに「大人」クラス、「子供」クラス、「シニア」クラスを作り、

区分ごとの名称と料金計算のロジックを、それぞれのクラスに分けて記述します。

* 区分ごとのロジックを別のクラスに分けて記述する
```
class AdultFee {
  Yen fee() {
    return new Yen(100);
  }

  String label() {
    return "大人";
  }
}

class ChildFee {
  Yen fee() {
    return new Yen(50);
  }

  string label() {
    return "子供";
  }
}

class SeniorFee {
  Yen fee() {
    return new Yen(80);
  }

  String label() {
    return "シニア";
  }
}
```

この例では、区分ごとにクラスを作り、それぞれのクラスに、区分ごとの料金計算方法と、日本語の名前を記述しています。区分ごとのクラスは、料金以外にも、

様々な区分ごとのロジックの置き場所になります。

このように、区分に関する様々なロジックを区分ごとのクラスに分けて記述すれば、区分ごとのロジックが整理され、

どこに何が書かれているか明確になります。

## 区分ごとのクラスを同じ「型」として扱う

区分ごとにクラスを分けると、ロジックの整理はしやすくなります。

しかし、問題があります。クラスを使う側は、

AdultFee型とChildFee型を使い分けるためのif文を書いてしまうと、

区分ごとにクラスを分けてコードを整理したメリットが失われます。

この問題を解決するのが、AdultFee型とChildFee型を同じ型として扱う仕組みです。

Javaではインターフェース宣言を使えば、異なるクラスを同じ型として扱うことができます。

インターフェースの使い方は簡単です。

料金区分ごとのクラスを同じ型で扱うためにFeeインターフェースを宣言します。

区分ごとのクラスは、自分がFee型の一員であることを宣言します。

* AdultFeeクラスとChildFeeクラスをFee型として宣言する

```
interface Fee {
  Yen yen();
  String label();
}

class AdultFee implements Fee {
  Yen yen() {
    return new Yen(100);
  }

  String label() {
    return "大人";
  }
}

class ChildFee implements Fee {
  Yen yen() {
    return new Yen(50);
  }

  String label() {
    return "子供";
  }
}
```

Fee型を使うと、料金を計算する側のコードはこうなります。
* Fee型を使う側のコード
```
class Charge {
  Fee fee;

  Charge(Fee fee) {
    this.fee = fee;
    // feeはAdultFee型またはChildFee型どちらでも良い
  }

  Yen yen() {
    return fee.yen();
  }
}
```

Chargeクラスのオブジェクトを生成する時に、コンストラクタにFee型のどのクラスのオブジェクトを渡すかによって、

Chargeクラスの振る舞いが変わります。

コンストラクタに渡すオブジェクトがAdultFee型であれば大人料金を計算します。

ChildFee型であれば子供料金の計算をします。

Chargeクラスは、AdultFee型とChildFee型の違いを意識していません。

どちらの型のオブジェクトもFee型のオブジェクトとして扱います。

インターフェースを使って異なるクラスを同じ型として扱う例も、

もう一つ考えてみましょう。子供連れの団体の合計料金の計算です。

## 子供連れの団体の料金の合計

```
class Reservation {
  List<Fee> fees; // 大人と子供の内訳は不明

  Reservation() {
    fees = new ArrayList<Fee>();
  }

  void addFee(Fee fee) { // 大人でも子供でも追加できる
    fees.add(fee);
  }

  Yen feeTotal() {
    Yen total = new Yen() // 合計ゼロ円
    for (Fee each : fees ) {
      total.add( each.yen() );
    }
    return total;
  }
}
```

大人料金と子供料金の場合わけのif文は登場しません。

Reservationクラスは、大人と子供を意識しないでFee型のオブジェクトの料金を合計しているだけです。

このようにインターフェース宣言(Fee)と、区分ごとの専用クラス(AdultFee/ChildFee)を組み合わせて、

区分ごとに異なるクラスのオブジェクトを「同じ型」として扱う仕組みを多態と呼びます

多態を使うと区分ごとに異なる判断/加工/計算のロジックをすっきりと整理できます。

区分ごとのロジックを別のクラスに分けて記述すれば、どのクラスに何が書いてあるか特定しやすく

変更が楽で安全になります。

例えば料金区分に「シニア」を追加する場合も、SeniorFeeクラスを作成して

Fee型として宣言するだけです。

シニア区分を追加しても、料金を合計するReservationクラスは何も変更する必要がありません。

Reservationクラスは、そもそもどのような料金区分が存在するのかを知りません。

知っているのはyen()メソッドで料金を返すFee型のオブジェクトだけです。

使う側のクラスが、実際にどのような区分があるのか「知らない」ことが重要です。

クラスとクラスの関係は、知っていることが多いほど密結合になります。

「知らない」ことが多いほど、クラス間の結びつきが弱くなります。

結合が弱いほど、独立性が高くなり、あるクラスの変更が他のクラスに影響することが減ります。

多態は、区分ごとのロジックをクラス単位に分離してコードを読みやすくするオブジェクト指向らしい仕組みです。

区分や追加や削除をしても、あちこちのコードを修正する必要はありません。

区分ごとの判断ロジックや計算式の変更の影響は、特定の区分クラスに閉じ込めることができます。

if文/switch文で駆使して場合分けを記述する手続き型のプログラムは、

変更が厄介で危険です。

それに比べ、多態を使ったオブジェクト指向らしい区分のかき分け方は、変更を楽で安全にします。
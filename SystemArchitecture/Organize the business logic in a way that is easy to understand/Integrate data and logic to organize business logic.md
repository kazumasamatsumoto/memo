## データとロジックを一体にして業務ロジックを整理する

### 業務ロジックを重複させないためにはどう設計すれば良いか

データクラスと機能クラスは「クラス」という仕組みを使っていますが、

実際はデータ構造と処理手順という典型的な手続き型の設計です。

オブジェクト指向では、データとロジックを一つのクラスにまとめます。

そして、それぞれのクラスを独立したプログラミング単位として開発し、テストします。

クラスにデータとそのデータを使う判断/加工/計算のロジックを一緒に書いておけば、

コードの重複をなくせます。

そのクラスを使う側のクラスに同じロジックを書く必要がなくなるからです。

使う側にロジックを書かなくてよくなければ、使う側のクラスのコードがシンプルになります。

その結果、プログラムの見通しがよくなり、修正の対象箇所が少なくなり、

変更の影響を狭い範囲に限定できます。

つまり、変更が楽で安全になるわけです。

クラス設計で大切なことは、使う側のクラスのコードがシンプルになるように

設計することです。

そういうオブジェクト指向らしいクラスを設計するには次の点に気を配ります。

* メソッドをロジックの置き場所にする
* ロジックを、データを持つクラスに移動する
* 使う側のクラスにロジックを書き始めたら設計を見直す
* メソッドを短くして、ロジックの移動をやりやすくする
* メソッドでは必ずインスタンス変数を使う
* クラスが肥大化したら小さく分ける
* パッケージを使ってクラスを整理する

それぞれについてみていきましょう。

### メソッドをロジックの置き場所にする

データクラスがうまくいかないのは、自分が持っているデータをそのまま別のクラスに

渡してしまうからです。

コードを重複させない設計の基本は、

インスタンス変数を返すだけのgetterメソッドを書かないことです。

* データを保持するだけのクラス（悪い例）
```
class Person {
  private String firstName;
  private String lastName;
  ...

  String getFirstName() {
    return firstName; // インスタンス変数をそのまま返す
  }

  String getLastName() {
    return lastName; // インスタンス変数をそのまま返す
  }
}
```

この例のgetFirstName()メソッドとgetLastName()メソッドはインスタンス変数を返すだけです。

何も役に立つことをしていません。

メソッドはもっと役に立つことを実行しなくてはいけません。

メソッドは判断/加工/計算のロジックを実行して初めて役に立つのです。

* メソッドにロジックを持たせる
```
class ParsonName {
  private String firstName;
  private String lastName;

  String fullName() {
    return String.format("%s %s", firstName, lastName);
  }
}
```

fullName()メソッドは、firstNameとlastNameの2つのインスタンス変数を連結して、空白区切りの使命を返します。

このように、インスタンス変数を使って何らかの処理を行うのがメソッドの正しい姿です。

インスタンス変数を使って何らかの処理を行うのがメソッドの正しい姿です。

インスタンス変数を使った加工や計算をしない、

インスタンス変数を返すだけのgetterメソッドは、メソッドの使い方として間違っているのです。

## 業務ロジックをデータを持つクラスに移動する

データを返すだけのgetterメソッドを見つけたら、そのメソッドに何らかの判断/加工/計算をさせることを考えます。

例えば数値データをgetするメソッドを考えてみましょう。

データをgetするクラスでは、そのデータを使って何か計算したいはずです。

その計算ロジックをgetterメソッドを持つクラスに移動します。

そうすると次のことが起きます。

* データを持つ側のクラスにロジック（計算式）が増える
* データをgetしていたクラスからロジック（計算式）が減る
* 使う側のクラスは、データをgetするのではなく、そのデータを使った計算結果を受け取るようになる

こうやってデータを持つクラスに業務ロジックを集めることがコードの重複や散在を防ぐ、

オブジェクト指向の基本です。

データを持つクラスにロジックを移動すればコードの重複をなくせます。

コードの重複がなくなれば、変更の対象箇所をそのクラスに限定できます。

データを持つクラスに判断/加工/計算を任せることができるため、

利用する側のクラスのコードはシンプルになり読みやすくなります。

### 使う側のクラスに業務ロジックを書き始めたら設計を見直す

どこでもいいからロジックを書いて、とにかく動かせばいいわけではありません。

ロジックをどこに書くのが良いかを適切に判断するのが「設計」です。

そして、データを持つクラスに、そのデータを使った

判断/加工/計算

のロジックを書くのがオブジェクト指向のクラス設計の基本です。

あるクラスを「データの入れ物」と考えてしまうと、

そのクラスからデータをgetして、自分でロジックを書くのが当たり前になってしまいます。

しかし、データを持つクラスのメソッドを「ロジックの置き場所」と考えれば、

そのクラスが判断/加工/計算までやってくれる便利な部品になります。

設計の初期の段階では、データを持つだけのクラスを作ることもあります。

業務でどのようなデータを扱っているかに注目するとクラスの候補を見つけやすいからです。

この段階でロジックを持たないデータクラスであることは問題ではありません。

データを持たないクラスに、データクラスからデータをgetして判断/加工/計算のロジックを書いてしまうこともあるでしょう。

設計の初期の段階はそれでも良いのです。

問題はとりあえず動くようになったあとです。

データとロジックを別のクラスに書いてあっても、動いたから良しとしてそのまま放置するのか。

それとも、データを持つ側にロジックを移動する設計改善を続けるか。

その違いが、ソフトウェアの変更容易性を大きく左右します。

データを持つクラスからデータをgetして、そのデータを使って

判断/加工/計算するロジックを書き始めたら、何か変だと考えましょう。

ロジックを書く場所が変だと気がついたらTO-DOとしてコメントを残しましょう

オブジェクト指向の設計は改善の繰り返しです。

最初からいい設計が見つかるわけではありません。

コードを書いて動かしてみながら、

ロジックの置き場所やクラス名/メソッド名の改善を続け、

より良い設計を見つけて行くのが、オブジェクト指向設計の基本です。

## メソッドを短く書くとロジックの移動がやりやすくなる

オブジェクト指向らしい設計を進めるには、メソッドは小さく分けて独立させます。

長いメソッドを短いメソッドに分けると、本来ならばそのクラスに相応しくないコードの塊を発見しやすくなります。

数行のコードの塊をメソッドとして独立させ、その数行のコードの塊を、

データを持つクラスに移動します。

そういう、ちょっとしたロジックの移動を繰り返してみると、

データとロジックが同じ場所にある方が、プログラムがわかりやすくなることが実感できます。

データを持つクラスにロジックを書くことが当たり前になってきます。

そうなると、データを持つだけのクラスは自然に書かないようになります。

最初から、データとロジックがひとかたまりになったクラスを作ることが当たり前になります。

こうやってオブジェクト指向らしい設計が身についてくると、

コードの重複がない、変更したときの影響範囲を狭い範囲に限定できるプログラムを短時間で書くことができるようになります。

## メソッドは必ずインスタンス変数を使う

インスタンス変数を使わないメソッドは、そのクラスのメソッドとしては不適切です。

ロジックの置き場所を再検討すべきです。

* 引数だけを使い、インスタンス変数を使わないメソッド(悪い例)
```
BigDecimal total(BifDecimal unitPrice, BigDecimal quantity) {
  BigDecimal total = unitPrice.multiply(quantity);
  return total.setScale(0, ROUND_HALF_UP);
}
```

このメソッドは渡された引数（unitPriceとquantity）だけを使って計算をしています。

インスタンス変数を使っていません。

インスタンス変数を使わないのであれば、このメソッドをこのクラスに置く意味がありません。

インスタンス変数を使わないメソッドは、どこに何が書いてあるかをわかりにくくします。

そのクラスに、そのメソッドを書いている理由がはっきりしないからです。

どこに何が書いてあるのか推測しやすくするためには、

データの近くにロジックを置く原則を徹底します。

インスタンス変数を使わないメソッドを見つけたら、

そのメソッドのロジックをデータを持つクラスへ移動することを検討します。

検討の結果、そのロジックを引数を渡している側のクラスに移動するのが良いかもしれません。

引数で渡すデータを持っていたのがさらにその先の別のクラスであれば、

そのクラスにロジックを移動すべきかもしれません。

## クラスが肥大化したら小さく分ける

インスタンス変数が多いクラスに関連する業務ロジックを集めると、

そのクラスが次第に大きくなります。

クラスが大きくなると、クラス内部でどこに何が書いてあるかわかりにくくなります。

また、何か変更した時に、副作用がないか心配をする範囲が広がります。

データを持つクラスにロジックを移動した結果、クラスが大きくなり始めたら、

関連性の強いデータとロジックを抜き出して、

新しいクラスに分けることを考えます。

まずはインスタンス変数とメソッドの関係を調べます。

それぞれのメソッドがどのインスタンス変数を使っているかに注目して、

メソッドをグループ分けします。

同じインスタンス変数を使うメソッドを一つのグループとしてまとめます。

* インスタンス変数とメソッドを対応付ける
```
class Customer {
  String firstName;
  String lastName;

  String postalCode;
  String city;
  String address;

  String telephone;
  String mailAddress;
  boolean telephoneNotPreferred;

  String fullName() {
    return String.format("%s %s", firstName, lastName);
  }

  ...
}
```

この例では、fullName()メソッドが使っているインスタンス変数は、firstNameとlastNameの2つです。

他のインスタンス変数を使っていません。

この場合、firstNameとlastNameだけを持つ別のクラスを作成し、

fullName()メソッドはそちらに移動します。

* メソッドが全てのインスタンス変数を使うようになる
```
class PersonName {
  private String firstName;
  private String lastName;

  String fullName() {
    return String.format("%s %s", firstName, lastName);
  }
}
```

こうやって別のPersonNameクラスに抽出すると、

fullName()メソッドは、そのクラスの全てのインスタンス変数を使うようになります。

同じように、インスタンス変数とメソッドの関係に注目すると、

AddressクラスやContactMethodクラスが抽出できそうです。

* クラスの抽出後
```
class Customer {
  PersonName personName;
  Address address;
  ContactMethod contactMethod;
}
```

関連するロジック（メソッド）は、それぞれのクラスに移動したので、

Customerクラスがすっきりしました。

抽出したPersonNameクラス、Addressクラス、ContactMethodクラスは、

密接に関係したデータとロジックだけになり、

独立性が高く再利用できそうな部品になります。

このように、関連性の強いデータとロジックだけを集めたクラスを

凝集度が高い

といいます。

凝集とは「切ってもきれない」関係です。

オブジェクト指向のクラス設計は、この切っても切れない関係のデータとロジックを一つのクラスにまとめる

「凝集」が基本です。

凝集したクラスは意図が明確で使いやすくなります。

同時に、そのクラス内部の変更が、他のクラスに影響しにくくなります。

つまり疎結合になります。

## パッケージを使ってクラスを整理する

インスタンス変数とメソッドの関係に注目しながらクラスを抽出すると、

クラスの数が増えます。

クラスが増えると、どこに何が書いてあるか見つけにくくなります。

クラスの数が増えてきたときの整理の手段が

パッケージです。

関連性の強いクラスは同じパッケージに集めます。

そして、クラスやメソッドのスコープ（参照範囲）は、

可能な限りパッケージスコープにします。

つまり、public宣言しないようにします。

publicなクラスやメソッドが少ないほど、

変更の影響範囲をパッケージに閉じ込めやすくなります。

パッケージのクラス数が増えたら、さらにサブパッケージに分けます。

また、クラス数が少なくても、長いパッケージ名を付けたくなったら、

パッケージを階層にして、一つ一つのパッケージ名を短くすることを検討します。

そのために階層が深くなったり、一つのパッケージに一つか2つのクラスになってしまうこともありますが

それでも良いのです。

名前を手掛かりに、どこに何が書いてあるかを推測する時に、

パッケージ名が単純で、1つのパッケージのクラスが少ない方が推測しやすくなります。

パッケージの設計も継続的に改善します。

パッケージの名前と、パッケージに含まれるクラスがずれてきたり、名前の階層関係が変わってきたら、

パッケージの名前の変更や、クラスのパッケージ間の移動、

パッケージの移動を行います。

ようやって、パッケージ単位でのコードの整理の改善を地道に続けることで、

コードの見通しを保つことができます。

開発初期のパッケージ構造は、少ない情報を元に浅い理解で設計されたものがほとんどでしょう。

開発が進むに連れて、対象領域の知識が広がり、

最初は見えていなかった全体の構造を理解できるようになってきます。

それに合わせて、パッケージの名前や構造を改善して行くことが、コードの見通しをよくし、

どこに何が書いてあるかをわかりやすく保つ基本です。
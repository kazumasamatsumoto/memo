## プログラムの変更が楽になる書き方

### わかりやすい名前を使う
名前のわかりやすさは、プログラムの読みやすさ/読みにくさに直結します。
名前が曖昧だったり、名前と内容が一致していないプログラムは読むのに苦労します。

* 1文字の変数名とか書くな!
* 文字を省略するな！
* ちゃんと長くても何をしたいか理解できる単語でかけ

プログラムを動かすだけであれば、変数名が1文字でも、省略形でも、きちんとした単語を使っても、どの書き方でも一緒です。

名前を考える労力やタイピングの量を考えれば、1文字の変数名が最も楽かもしれません。

しかし、プログラムを変更するために、どこに何が書いてあるかを調べるときにはどうでしょうか？

変数名に意味のある単語を使った書き方が最もわかりやすいはずです。

1文字の名前は、コードを読んでも何を意味しているのかわかりません。
どこに何が書いてあるかを理解するまでに、苦労します。

qtyやupなど省略した名前は、前後の関係から数量と単価であることを推測できるでしょう。

しかし、略語はいろいろな意味に解釈できます。
そのため、正しい意味の推測に時間がかかります。

また、人によって意味の取り違えも起きそうです。

quantityやunitPriceという変数名は、数量と単価であることが一目瞭然です。読むことに負担はなく意味の取り違えの心配もありません。

a,bのように1文字の変数名だったり、qtyやupという略語形式の名前は、プログラミングの世界ではよく見かけます。
しかし、私たちが日常の会話や文章で使う表現からはかけ離れています。

そのプログラムが何をしているのか理解するには、1文字や略語形式は障害になります。

プログラムに使う名前も普通の単語を使います。

そのアプリケーションが対象とする分野で普通に使われている言葉を、そのままプログラムの変数名やクラス名に使います。

そうすることで、どのような業務のために何をしているプログラムなのかわかりやすくなります。

どこに何が書いてあるかを調べることが、簡単で確実になります。

業務で使っている言葉をそのままプラグラム要素の名前に使うことで、
プログラムの変更が楽で安全になります。

### 長いメソッドは「段階」に分けて読みやすくする

だらだらと切れ目なく書かれたコードは読みにくく、理解が大変です。

そういうプログラムを読みやすくする簡単な方法が、空白行を使ってコードのまとまりに切れ目を入れることです

```
こう言った形で改行していないパターンは見づらいよね
int price = quantity * unitPrice;
if( price < 3000 )
  price += 500; // 送料
price = price * taxRate();
```

空白行を入れて3つの段落に分けたコード
```
int price = quantity * unitPrice;

if( price < 3000 )
  price += 500; // 送料

price = price * taxRate();
```

4行のコードを、空白行を使って3つの段落に分けました。空白行の入らない前者に比べると、次に3つのステップが見た目にはっきりします。

* ベース価格の計算
* 送料の加算
* 税額の加算

プログラムを読みながら、前後の行と意味が異なる場所を見つけたら、積極的に空白行を追加して段落に分けましょう。

コードの意味のまとまりごとに段落を分けると、変更の対象範囲が特定しやすくなります。

例えば「送料の変更」ならば、変更の対象箇所は2番目の段落だけです。
前後の段落は送料変更とは直接は関係しません。

### 目的ごとに変数を用意する

段落を分けることで変更の対象箇所を特定しやすくなりました。しかし、このコードは、まだ変更のやりにくさが残っています。

その理由は、ローカル変数priceを次の3つの用途に使いまわしているからです。

* 数量*単価の計算結果
* その計算結果に送料を加算した結果
* さらに、その加算した結果に税率を適用した値

このように、一つの変数を複数の目的に使い回すとコードを読むときに混乱します。

中間結果も最終結果も、同じprice変数として扱うと途中で何をやっているか、わかりにくくなります。

また、ローカル変数priceを使い回すと変更の影響範囲が広がります。
同じローカル変数を使っている範囲に、変更が波及します。本来は関係のない箇所に影響する予想外の副作用の原因になります。

変更の影響範囲を狭くするために、目的ごとに別々のローカル変数を用意します。

<br>ちゃんと目的ごとに変数を用意しろよ！！</br>

目的ごとのローカル変数を使う
```
int basePrice = quantity * unitPrice;

int shippingCost = 0;
if( basePrice < 3000 )
  shippingCost = 500;

int itemPrice = (basePrice + shippingCost) * taxRate();
```

それぞれの計算のステップごとに専用のローカル変数を用意しました。
ローカル変数の名前で、それぞれのステップの計算の目的が明確になりました。

* basePrice :数量*単価
* shippingCost :送料
* itemPrice :税込金額

price変数を3つの目的に使いまわしたコードは、price変数を通じて、
最初の段落と最後の段落が強く結びついています。

それに対し、目的ごとに専用のローカル変数を用意すれば段落の結びつきが弱くなり、独立性が高まります。目的別の変数を用意する、ちょっとした工夫が変更の影響範囲を局所化します。

<br>変数に独立性を持たすことによって変更の影響範囲を局所化する</br>

目的別に専用のローカル変数を用意し、コードの意図を変数名で説明するやり方を説明用の変数を導入と呼びます。

既存のコードの設計の改善するリファクタリングの基本テクニックです。

最初に示したprice変数の例のように、1つの変数を使いまわして代入を繰り返す書き方を破壊的代入と呼びます、破壊的代入は変更の副作用を起こしやすい書き方です。

用途ごとに「説明用の変数」を積極的に導入して破壊的な代入をなくします。

破壊的な代入がなくなればプログラムを変更したときの副作用が減り、コードが安定します。

### メソッドとして独立させる

空白行を使って「段落」に分け、段落ごとに「説明用の変数」を導入すると、一つ一つの段落を独立性が高くなります。

この独立性が高くなった段落を「メソッド」として独立させると、さらにコードがわかりやすくなり、変更が楽で安全になります。

「段落」は見た目の工夫です。人間にとっての読みやすさは向上します。

しかし、プログラムの構造は変わっていません。

段落をメソッドとして独立させると、プラグラムの構造が変化します。

メソッドが独立した1つの部品になります。

あるメソッド内での変更の影響を、そのメソッドに閉じ込めやすくなります。

送料計算をメソッドにする
```
int basePrice = quantity * unitPrice;

int shippingCost = shippingCost(basePrice); //　送料計算メソッド

int itemPrice = (basePrice + shippingCost) * taxRate();

...

// メソッドに独立させた送料計算ロジック

int shippingCost(int basePrice) {
  if ( basePrice < 3000)
    return 500;

    return 0;
}
```

送料を計算するためのデータとロジックをshippingCost()メソッドに切り出し、独立させました。

送料計算だけに使うデータ(3000円と500円)とそのデータを使った場合わけのif文をshippingCost()メソッドの内部に閉じ込めました。

この結果、メインの処理はif文が消え、単純でわかりやすいコードになります。

メソッドとして独立させると、送料計算のルールを変更するときに、修正箇所をshippingCost()メソッドの内部に限定できます。送料計算のロジックや計算に使う値を変更しても、このメソッドを使う側のコードには影響しません。

段落に埋もれていた送料計算のロジックとデータをshippingCost()メソッドに独立させるこのやり方をメソッドの抽出と呼びます。

変更のやりにくいプログラムを改善するリファクタリングの基本中の基本のテクニックです。

メソッドの抽出のメリットは次の通りです。

* 詳細をメソッドに移動するため、元のコードがシンプルになり読みやすくなる
* メソッドの名前からコードの意図を理解しやすくなる
* メソッド内に変更の影響を閉じ込めやすくなる

また、関連性が強いデータとロジックをメソッドに抽出すると、ロジックを再利用しやすくなります。

長いメソッドの中に埋没した送料計算のロジックは、プログラムの別の場所から利用できません。

同じ処理が必要になったときに、送料計算のコードを複製して使うことになります。

こういうちょっとしたコードの複製が、プログラムの変更を面倒で危険な作業にします。

複製はコードの重複です。

プログラムの全体を調べて重複したコードを全て洗い出し、修正し、変更結果を確認をするのは手間がかかる作業です。

修正箇所が多ければ修正ミスも起きがちです。

メソッドの抽出はコードの重複を防ぎます。

送料を計算する専用のshippingCost()メソッドは、必要な場所であれば、どこからでも利用できます。

複製によるコードの重複がおきません。

送料計算に関する変更はshippingCost()メソッド１箇所に限定できます。

数行のコードをメソッドに抽出するやり方は、処理の流れが分断され、慣れないと帰って読みにくく感じるかもしれません。

しかしメソッドの抽出をすることによって、重複をなくした変更箇所を１箇所に限定する効果は絶大です。

あちこちに重複したコードの変更は厄介で危険です。

メソッドに切り出して１箇所に閉じ込めたロジックの変更は楽で安全です。

### 異なるクラスの重複したコードをなくす

1つのクラスの中であれば、メソッドに抽出するだけで、重複したコードをなくせます。

しかし、異なるクラスにロジックが重複している場合は少し工夫が必要です

2つのクラスのコードの重複を解消する手順は下記のようになります。

* 手順1 それぞれのクラスで該当するコード部分（段落）を、メソッドに抽出する

* 手順2 2つのクラスに参照関係がある場合：参照する側で抽出したメソッドの呼び出しを、参照先のオブジェクトのメソッドの呼び出しに書き換える

* 手順2' 2つのクラスに参照関係がない場合：共通のメソッドの置き場所として、別のクラスを新たに作成し、元のクラスで抽出したメソッドを移動する

* 手順3 元の2つのクラスのメソッド呼び出しを、それぞれ新しいクラスの共通メソッドを利用するように書き換える

手順2' の「2つのクラスに参照関係がない場合」を具体例で考えてみましょう

例えば、「注文」クラスと「注文変更」クラスのどちらも送料計算が必要な場合です

共通ロジックの置き場所として「送料」クラスを作り、送料計算のロジックをそこに移動します。

そして「注文」クラスと「注文変更」クラスのそれぞれが、この「送料」クラスを使うようにします。

送料クラス
```
class ShippingCost {
  static final int minimumForFree = 3000;
  static final int cost = 500;

  int basePrice;

  ShippingCost(int basePrice) {
    this.basePrice = basePrice;
  }

  int amount() {
    if( basePrice < minimumForFree ) return cost;
    return 0;
  }
}
```

送料クラスを使う側のコード
```
// 送料を算出する
int shippingCost(int basePrice) {
  ShippingCost cost = new ShippingCost(basePrice);
  return cost.amount();
}
```

送料クラス(ShippingCostクラス)では、送料計算の対象になる金額(basePrice)ごとにコンストラクタで別々のオブジェクトを作ります。

計算の対象になる値が異なれば、別のオブジェクトに分けるのがオブジェクト指向らいし設計です。

対象金額ごとで別のオブジェクトに分けておくと、

対象金額が複数あった場合に誤って別の対象金額を使って計算してしまう不具合を防げます。

送料計算が必要な時は、この送料クラスを再利用します。

このように用途を限定した小さなクラスが、

ロジックの再利用を促進し。

コードの複製や重複を防ぎます。

### 狭い関心事に特化したクラスにする

送料クラスは、送料に関連する次の知識を持っています。

* 送料が無料になる注文金額(3000円)
* 送料(500円)
* 注文金額を判断して、適切な送料を計算するロジック

送料クラスの関心事は送料だけです。

送料以外の関心事は登場しません。

こういう特定の関心事に特化した小さなクラスが、コードの見通しを良くし、変更をやりやすくします。

送料計算のロジックが長いメソッドの中に埋没すると、

変更の対象箇所の特定に時間がかかります。

メソッドが長いとメソッドの他の箇所に影響が出ないかの確認に時間がかかります。

そのメソッドには、送料の計算が出ないかの確認に時間がかかります。

そのメソッドには、送料の計算以外に、

割引りつや特別価格の計算が書いてあるかもしれません。

複数の関心事が混ざっているコードは、気が散る要素も多く、

読んで理解するのが大変です。

送料計算に関するデータと計算式だけを抜き出して、

送料クラスに独立させておけば、変更の対象と影響範囲を送料クラスに限定できます。

送料クラスに書いてあるのは送料計算だけですから、

余計なことを考えずにコードを読んで修正できます。

将来、送料に関するビジネスルールの変更が発生した時にも、

対象箇所と影響範囲をこのクラスに限定できます。

また、「送料」という業務の言葉が、そのまま「送料」クラスというプログラムの単位と対応しています。

ですから、プログラムの全体の中から「送料」に関する記述を見つけるのは簡単で確実です。

「送料」クラスのように、業務で使われる用語に合わせて、

その用語の関心事に対応するクラスをドメインオブジェクトと呼びます。

アプリケーションの対象領域（ドメイン）の関心事を記述したオブジェクトという意味です。

このように業務の用語と、直接対応するドメインオブジェクトを用意することが、

業務アプリケーションの変更を用意にするオブジェクト指向らしい設計のアプローチです。

また、業務を理解するために要求を分析し、そこで発見した業務の関心事の単位を、

そのままプログラミング単位としてクラスで表現するのが、

オブジェクト指向開発のやり方です。

分析で発見した業務の構造とプログラムの構造が一致していれば、変更が楽で安全になります。

修正や拡張が必要になった時、どこに何が書いてあるかも特定しやすくなります。

### メソッドは短く、クラスは小さく

プログラムを読みやすくし、変更をやりやすくする、5つのやり方を説明してきました。

・名前は（略語ではなく）普通の単語を使う
・数行のコードを意味のある単位として「段落」に分ける
・「目的別の変数」を使う（1つの変数を使いまわさない）
・意味のあるコードのまとまり（段落）を「メソッド」として独立させる
・業務の関心事に対応したクラス（ドメインオブジェクト）を作る

「送料」というう関心事に限定してコードを整理した結果、

数行の短いメソッドを持つ、10行ほどのクラスになりました。

業務の関心事の単位で記述した結果が、短いメソッドや小さなクラスになるなら、

積極的にそうすべきです。

送料計算はたった２行の計算式です。

その２行の計算式が複数のクラスで重複するなら「送料」クラスに抽出します。

コードの意図をわかりやすく説明するためなら、１行の計算式でもメソッドに独立させます。

「短いメソッド」と「小さなクラス」は変更を楽で安全にします。

・メソッド名やクラス名が変更の対象箇所を特定する手がかりになる
・コードの重複がなくなり、修正箇所が１箇所になる
・コード変更の影響を、メソッドやクラスに閉じ込めやすい

変更に苦しむのは、いつでも長いメソッドと大きなクラスです。

「メソッドの抽出」と「クラスの抽出」によって、コードを「短いメソッド」と「小さなクラス」に小分けして整理するのが、

変更を楽で安全にする設計の基本です。

そして、メソッド名やクラス名を、業務の関心事、業務で普段使われている言葉と一致させ、

どこに何が書いてあるかをわかりやすくします。


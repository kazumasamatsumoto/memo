# 複雑さを閉じ込める

## 配列やコレクションはコードを複雑にする
同じ型のオブジェクトを複数持つ配列やコレクションを扱うコードは複雑になりがちです。

・for文などループ処理のロジック
・配列やコレクションの要素の数が変化する（可能性がある）
・個々の要素の内容が変化する（可能性がある）
・ゼロ件の場合の処理
・要素の最大数の制限

こういう配列やコレクションを扱うコードが、プログラムのあちこちに散らばり始めると
コードが読みにくくなり、変更が厄介で危険になります。

配列やコレクション型を操作するロジックを、専用の小さなクラスにまとめて整理することで、プログラムがわかりやすくなり、変更がやりやすくなります。

## コレクション型を扱うコードの整理

List/Set/Mapなどのコレクション型は、業務データを扱うための基本的なデータ構造です。
コレクション型には、次のような基本操作が用意されています。

* add()
* remove()
* get()
* size()
* contains()
* subList()

しかし、業務ロジックを表現するにはこれらの基本操作だけでは足りず、
for文やif文を用いた、もっと複雑な処理が必要です。

ループ構造が入れ子になったり、

if文の場合分けが増えてきます。

そうなると、内容を正しく理解することが難しくなり、
変更が厄介で危険になります。

コレクションを操作するコードが、プログラムのあちこちに散らばると、
状況はさらに悪化します。

例えば次のような場合です。

* プログラムのある場所で、コレクションに要素を追加する
* 別の場所で、同じコレクションの要素を削除する
* さらに別の場所で、コレクションの要素のデータ内容を書き換える

こういうプログラムで、コレクションの状態を正しく把握することは至難の技です。

コレクションを操作するロジックを変更した時に、期待した動作にならなかったり、

思わぬ副作用が起きがちです。

コレクション操作のコードを整理して、変更の影響範囲をコントロールしやすくするには
どうすればいいでしょうか？

## コレクション型を扱うロジック
考え方は値オブジェクトと同じです。
データと関連するロジックは、1つのクラスに集めます。
int型の変数を1つ持った「数量」の専用クラスを独自に作ったように、
コレクションList<Customer>型の変数を1つだけ持った「顧客一覧」の専用クラスを独自に宣言します。

コレクション型のインスタンス変数を1つだけ持つ専用クラス
```
class Customers {
  List<Customers> customers;

  void add(Customer customer) { ... }
  void removeIfExist(Customer customer) { ... }

  int count() { ... }

  Customers importantCustomers() { ... }
}
```

そして、List<Customer>を操作するロジックは、全てこのCustomersクラスに集めます。

顧客の追加や削除、顧客数のカウント、特定条件で絞り込んだ顧客の抽出などのロジックです。

そうやって、全てのロジックをこのCustomersクラスに集めておけば、ロジックを変更するときの影響をCustomersクラスに閉じ込めやすくなります。

Customersクラスでは、List<Customer>以外のインスタンス変数を持たないようにします。

Customersクラスの意図を明確にし、コードを簡潔に保つためです。

このように、コレクション型のデータとロジックを特別扱いにして、コレクションを一つだけ持つ専用クラスを作るやり方を`コレクションオブジェクト`あるいは`ファーストクラスコレクション`と呼びます。

コレクションを操作するロジックをコレクションオブジェクトに閉じ込めると、コレクションオブジェクトを使う側のコードが単純になります。

要素数のチェックやループ処理は、全てコレクションオブジェクトがやってくれます。

使う側はコレクションオブジェクトのメソッドを呼ぶだけです。

値オブジェクトやコレクションオブジェクトのように、あるクラスにデータとロジックを閉じ込めると、

そのオブジェクトを使う側のロジックが簡単になります。

このように、使う側のプログラムの記述が簡単になるように、使われる側のクラスに便利なメソッドを用意するのがオブジェクト指向設計のコツです。

メソッドの内部で、一時的にListやSetを生成して操作する数行の処理でも、コレクションオブジェクトを作ります。処理の詳細はコレクションオブジェクトに任せます。

そうすることで、元のメソッドの記述がシンプルになります。

同じようなコレクション操作の記述の複製がプログラムのあちこちに増殖しなくなります。

## コレクションオブジェクトを安定させる

値オブジェクトと同じようにコレクションオブジェクトも、できるだけ「不変」スタイルで設計します。
そのほうがプログラムが安定します。
CustomersクラスにgetList()など、List<Customer>をそのまま返すメソッドを用意してはいけません。

List<Customers>への参照をそのまま外部に渡すと、要素の追加や削除がCustomersクラスの外部からできてしまいます。

これではコレクションの状態が不安定になり、コレクションオブジェクトのメリットを失います。

コレクションの参照をそのまま渡すメソッド(悪い例)
```
class Customers {
  List<Customer> customers;

  ...

  List<Customer> getList() {
    return customers;
  }
}
```
コレクションの操作を安定させる方法は、3つあります。

* コレクション操作のロジックをコレクションオブジェクトに移動する
* コレクション操作の結果も同じ型のコレクションオブジェクトとして返す
* コレクションを「不変」にして外部に渡す

コレクションへの参照を返すgetList()メソッドが必要だと感じたら、

一旦立ち止まって考え直しましょう。

List<Customer>を受け取る側でやりたいことを調べます。
そして受け取る側がやろうとしている、コレクションに対する判断/加工/計算のロジックをCustomersクラスに移動できないかを検討します。

操作対象のデータを持つクラスにロジックを集めることがオブジェクト指向設計の基本です。

データを持つクラスにロジックを集めると、使う側のクラスと使われる側のクラスのどちらのコードもわかりやすくなります。

addやremoveのように内部のList<Customer>の要素を変化させる操作では、操作の結果をCustomersクラスの別のオブジェクトを作って返すやり方があります。

値オブジェクトと同じやり方です

* コレクション操作の結果を同じ型のコレクションオブジェクトを作って返す(良い例)
```
class Customers {
  List<Customer> customers;

  ...

  Customers add(Customer customer) {
    List<Customer> result = new ArrayList<>(customers);
    result.add(customer);
    return new Customers(result);
  }
}
```

現在のコレクション内容と状態が異なるコレクションは、別のオブジェクトになります。

つまり、個々のコレクションオブジェクトは、内部のコレクションの状態が変化しない不変のスタイルのオブジェクトになります。

その結果、コレクションの状態を操作するロジックを使っても副作用が起きにくくなり、プログラムの動作が安定します。

どうしてもコレクションを渡す必要がある場合も、List<Customer>customersへの参照をそのまま渡してははいけません。変更不可のコレクションに変換して渡します。

* コレクションへの参照は変更不可にして渡す（良い例）
```
class Customers {
  List<Customer> customers;

  ...

  List<Customer> asList() {
    return Collections.unmodifiableList(customers);
  }
}
```

unmodifiableList()メソッドで作成したListは、要素の追加や削除ができなくなります。
しかし、これだけでは十分ではありません。

unmodifiableなListでも、個々の要素のオブジェクトの内容は変更できます。

コレクションの要素を値オブジェクトにすればこの変更も防げます。

値オブジェクトのコレクションを、unmodifiableList()を使って外部に渡すようにすれば、ソフトウェアの動作が安定し、変更の副作用が起きにくいプログラムになります。


* コレクションの要素を変更できてしまうと副作用が起きやすい
```
void modifyCustomer() {
  List<Customer> list = customers.asList();

  // リストの最初の要素を取り出す
  Customer first = list.get(0);

  // Customerが不変オブジェクトでないと、以下の操作ができてしまう
  first.setName("別の名前");
}
```

## コレクションオブジェクトは業務の関心事
コレクションを操作するロジックを整理する手段としてコレクションオブジェクトを説明した。

コレクションオブジェクトは、たいていの場合、業務の関心事そのものです。

売れ行きが好調な「商品の一覧」とか、購入回数の多い「顧客の一覧」という業務の関心事を、そのままクラスで表現したものがコレクションオブジェクトです。

コレクションオブジェクトも値オブジェクトと同じように、「業務の関心事」と、プログラミング単位である「クラス」を１対１に対応させる工夫です。

業務の関心事とプログラミング単位が一致していれば、業務ルールが変わった時に、プログラムの変更対象箇所を特定しやすくなります。

また、変更の影響範囲を特定のクラスに閉じ込めやすくなります。

顧客や商品の一覧は業務の重要な関心事です。

一覧を対象にした様々な判断/加工/計算には、様々な業務の関心事を表現する手段であり、

同時に業務ロジックをわかりやすく整理し、コードの変更を楽で安全にする工夫なのです。

## まとめ
* オブジェクト指向設計は変更を楽で安全にする工夫
* コードの整理の基本は名前と段落
* 短いメソッド、小さなクラスを使ってコードを整理する
* 値オブジェクトでわかりやすく安全にする
* コレクションオブジェクトで、複雑なロジックを集約して整理する
* クラス名やメソッド名と業務の用語が一致するほど、プログラムの意図がわかりやすくなり、変更が楽で安全になる

コレクションオブジェクトって何？
そもそもコレクションって何？

https://eng-entrance.com/java-collection

要素を一つにまとめたオブジェクト、コンテナと呼ばれることもある。

## 小さなクラスでわかりやすく安全に

送料クラスのような目的を限定した小さなクラスが業務アプリケーションの基本部品になります。

業務アプリケーションが扱う様々なデータとロジックをわかりやすく整理する基本が、

送料クラスのように特定の目的に特化して、関連するデータとロジックを小さなクラスにまとめること。

このような基本部品のクラス設計について、もう少し考えてみましょう。

### データとロジック

プログラムの基本、データを使った演算（判断/加工/計算）です。

業務アプリケーションで演算の対象になる基本データ型は次の3つです。

### 業務アプリケーションの基本データ型
| データの種類 | 用途 | Javaでの表現方法 |
|:-----------|:------------|:------------|
| 数値       | 金額、数値    |int, BigDecimal |
| 日付        |予定日、注文日、有効期限 |LocalDateなど    |
| 文字       |氏名、電話番号、説明 |Stringなど     |

この３種類の基本データ型を対象に、業務の約束事にしたがって、

「判断」「加工」「計算」を記述するのが業務ロジックです。

### 業務に使うデータと業務ロジックの例
| データの種類 |業務ロジックの例 |
|:-----------|:------------|
| 金銭|合計、小数点以下の「端数計算」、３桁ごとのカンマ編集、千円単位にまとめて表示|
| 有効期限|期限切れの判定、期限までの残日数の計算 |
| 電話番号|「市外局番-市内局番-加入者番号」の形式に加工、「市外局番」から地域を判定|

業務アプリケーションは、このような基本データ型とそれを使った判断/加工/計算のロジックを最小単位として、それらを組み合わせた物です。

### 基本データ型の落とし穴

数量や金額などの数値データは、intやBigDecimalを表現します。

しかし、これは業務の意図から考えると、乱暴なやり方です。

* intは、マイナス21億からプラス21億の範囲の変数
* BigDecimalは、実質的に無限の範囲の数（小数点も21億桁まで扱える）

一般的には、数量は正の整数です。多くの場合、最大値は100とか1000くらいまで扱えれば十分です。

金額も最大でも数百億円とか、場合によっては数千円で十分ということもあります。

### 怪しげな数量や金額の宣言

```
int quantity;
BigDecimal amount;
```

業務アプリケーションとして、この書き方は危険です。

このコードは、数量（quantity）をマイナス２１億からプラス２１億まで、

金額（amount）を実質的に無限大かつ小数点２１億桁まで扱うように宣言しています。

つまり業務の関心事とはかけ離れた異常な値を扱うことを宣言しています。

文法的には問題ありません。しかし、こういう書き方は、思わぬ障害が混入する原因になります。

### 値の範囲を制限してプログラムをわかりやすく安全にする

業務アプリケーションで数量を扱う時、intの全ての範囲（マイナス21億~プラス21億）
が必要になることはありません。

「0より大きく100より小さい」など、もっと狭い範囲の値が業務的に正しい値です。

その業務的に正しい値を扱うためにはQuantityクラスを独自に宣言して異常な値を扱わないようにしています。

### 正しい数量を扱うための独自クラス（Quantityクラス）を定義する

```
class Quantity {
  static final int MIN = 1;
  static final int MAX = 100;

  int value;

  Quantity(int value) {
    if(value < MIN) throw new IllegalArgumentException("不正:" + MIN * "未満");
    
    if(value > MAX) throw new IllegalArgumentException("不正:" + MAX + "超");

    this.value = value;
  }

  boolean canAdd(Quantity other) {
    int added = addValue(other);
    return added <= MAX;
  }

  Quantity add(Quantity other) {
    if( ! canAdd(other) ) 
      throw new IllegalArgumentException ("不正:合計が" + MAX + "超");
    
    int added = addValue(other);
    return new Quantity(added);
  }

  private int addValue(Quantity other) {
    return this.value + other.value;
  }
}
```

このように計算結果を含めて、数量が１以上で100以下であるように制限したQuantityクラスを用意することで、数量計算が安全で確実になります。

文字情報も同じです。

String型は全ての文字種を、実質的に無制限の長さで扱えます。しかし、そういう業務のニーズはありません。

例えば固定電話の電話番号をString型で表現することを考えてみましょう。
国内の固定電話の電話番号は次のルールがあります。

* 使える文字種は数字だけ
* 市外局番は"0"で始まる
* 合計の桁数は10桁
* 形式は、"市外局番 - 市内局番 - 加入者番号"
* 加入者番号は4桁固定
* 先頭の"0"を除いた市外局番は1桁から4桁

この電話番号を扱う変数を、String型で宣言しただけでは、以下の意味になります。

* 文字の種類は数字だけではなく漢字でも記号でもなんでも良い
* 長さは無制限
* 形式は自由

電話番号をString型で扱うと、実際にこういう不適切なデータが混入する可能性があります。

そしてそれが思わぬバグの原因になります。

文字列でデータを扱う場合、長さ/有効な文字種/正しい形式を、業務のルールや必要に合わせて、きちんと制約するのが業務アプリケーションとしてのあるべき姿です。

そのためには、電話番号はString型のデータではなく、独自にTelephone型としてクラス宣言をします。

電話番号として妥当な長さや文字種のルールを、Telephoneクラスに明示的に記述します。

電話番号を扱う場合は、必ずTelephone型のオブジェクトとして扱えば、正しいデータであることを保証できます。

Quantity型やTelephone型のように目的に特化した「型」を宣言し、利用することで、ソースコードは見違えるように意図が明確になり、動作も安定します。

「数量」は単なるintではありません。「電話番号」は単なるStringではないのです。

### 「値」を扱うための専用のクラスを作る

業務アプリケーションをオブジェクト思考で設計する場合には、業務で扱うデータの種類ごとに専用の「型」（クラスやインターフェース）を用意します。

専用の型は業務的に不適切な値が混入するバグを防ぎます。

業務ルールの変更が必要になったときにも、クラス名やインターフェース名を手掛かりに変更の対象箇所を特定しやすくなります。

変更の影響範囲もその型のクラス内に閉じ込め安くなります。

先ほどの例では、電話番号が関係するのはTelephone型を使っている箇所だけです。

値の種類ごとに専用の型を用意するとコードが安定し、コードの意図が明確になります。

このように、値を扱うための専用クラスを作るやり方を値オブジェクト（Value Object）と呼びます。

業務アプリケーションでよく使う値オブジェクトを表に示します。

どの値オブジェクトも、int型/String型/LocalData型など基本データ方のインスタンス変数を1つか2つ持つだけの小さなクラスになります。

### 業務アプリケーションでよく使う値オブジェクト

| 値オブジェクト | 内容 |
|:-----------|:------------|
| 数値系の値オブジェクト|　|
| Quantity | 数量（と単位）|
| Unit | 単位 |
| Amount | 金額 |
| Money | 金額と通過 |
| Currency | 通過 |
| 日付系の値オブジェクト |　|
| Days | 日数 |
| Hours | 時間数 |
| Period | 期間（開始日+終了日）|
| DueDate | 予定日、期日 |
| DateOfRecord | 記録日 |
| DateOfOccurrence | 発生日 |
| YearAndMonth | 年月 |
| 文字列系の値オブジェクト |　|
| Telephone | 電話番号 |
| Email | 電子メールアドレス |
| Url | ホームページURL |
| Line | 1行のテキスト |
| Description | 説明（複数行のテキスト）|
| Note | メモ（複数行のテキスト+作成日時と作成者） |
| Definition | 見出語と説明のペア |

表からわかるように、値オブジェクトは業務の用語そのものです。

* 業務で扱う情報の名前
* 業務上の判断や計算に使う用語

このように、業務の用語をそのままクラス名やメソッドとして使うと、プログラムが
業務の説明書になってきます。

業務ルールが変更があったときにも、クラス名と業務の用語が一致していれば、プログラム上で変更が必要な箇所を直感的に特定できます。

その業務に関係するデータとロジックを特定のクラスに集めて整理しておけば、変更の影響範囲をそのクラスに閉じ込めやすくなります。

それに対して値オブジェクトを使わない場合はどうでしょうか。

コードはint型やString型だらけになります。

そういうソースコードは、コンピュータに対するデータ操作命令としては有効です。

しかし、動かすことはできても、そのコードが業務的に何をやっているのか、プログラムを読んだだけでは理解できません。

こういうコードは業務ルールの追加や変更がやりにくくなります。

また、int型やString型が扱える値の範囲は、業務で必要な値の範囲とはかけ離れています。

そういう値を扱えてしまうプログラムは、思わぬバグを生みがちです。

業務で扱うデータの種類ごとに値オブジェクトをうまく作って、「業務でやりたいこと」と「プログラムでやっていること」の間の対応を取りやすくします。

業務用語をそのままクラスにした値オブジェクトを使えば、業務の関心事とコード表現が一致します。

その結果、業務アプリケーションの変更は楽で安全になります。

